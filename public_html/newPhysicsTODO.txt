
Update code flow to match new flow diagram

refactor to InputEvent heap. ASSERT always empty at end of update. (No inputs should be able to be passed to update with a timestep AFTER the update time).
add PredictedEvent heap that is reset upon input changes or collisions.
add EndEvent heap that causes an event handling the end of something (essentially the expiration of a timer that started at a previous event).

CRITICAL:
	FIX HOW BALL IS BEING STEPPED ROFL PRETTY SURE MINE IS COMPLETELY WRONG. MAYBE TEST THOUGH BECAUSE MY APPROX MIGHT BE RIGHT BECAUSE CONSTANT ACCELS?
		The equation for the ball's position at a given time t is:
		x(t) = 1/2 * Accelx * t^2 + Velx * t + x
				PRETTY SURE I'M USING A BAD CALCULATION RIGHT NOW.
		Implement getNewStateAtTime(timeDeltaFromCurPlayerModelState) which returns the above calculations into the new state. ENSURE EVERYWHERE IN THE CODE THAT STEPS TO NEW STATE USES THIS METHOD.
		
	ADD HACKEY MAX_MOVE_DISTANCE as fraction of radius. Use to ensure small steps between collision checks to avoid frame aliasing against line endpoints.


OBJECT CollisionData:				Collision.js
	RETURN:
		What was collided with.
		The EXACT time of the collision
		The collisions normalVec and surfaceVec (which represents the perp to the normalVec, not necessarily the surface collided with) ONLY IF THIS IS A SURFACE THAT MAY BE COLLIDED WITH.		
	
COLLISION TESTING:					Collision.js
	Refactor CollisionData object to include the time of the collision(s).
	Refactor getCollisionData to do all collision testing and call the calculus methods and return the time of most relevant collision(s) in a CollisionData object.
	Do not check getCollisionData collisions against currently "on" surfaces, or its predecessor or successor terrain (Stored in playerModel state).

COLLISION TIME RETRIEVAL:
	Implement getTimeOfCollision(collideableToGetTimeOfCollisionWith) for points and lines. (SEPERATE METHOD FOR EACH IS PROBABLY MOST EFFICIENT WAY).
		Implement new methods getTimeToLine
	
		
COLLISION HANDLING:					Physics.js
	BOUNCE: 
		Write function to project velocity of ball onto the collision normal of surface to retrieve the collision force vector. Use this to decide whether or not to allow bounce.
				Positive y means collision force downwards so do snapping logic there
				Negative y means collision force upwards, always bounce unless lock is held.
	LOCK:
		As with bounce above, project velocity of ball onto collision normal of surface, but then compare to velocity of ball projected onto surface vector itself. 1:1 ratio is how dustforce allows groundboosting, but others may be used.






FURTHER DOWN THE LINE:
	add InputBuffer heap. Inputs that end up ignored upon happening may be buffered. This buffer is checked on relevent events (jump buffered on a new collision? etc).

	COLLISION TESTING:				Collision.js
		Implement line against line collision checking and use in getCollisionData, as well as using current end radius collision checking. 
				Greatly reduces chance of missing a collision based on frame aliasing. Still use a max step distance OR test how different old velocity angle was from new velocity angle to determine whether to tween-test for more accurate motion profile. UNDERSTAND THIS WILL BE COSTLY, MAY REQUIRE GETTING RID OF BRUTE FORCE COLLISION CHECKS.
				Uses the line between the balls original center pos and the balls resulting center pos. Then offsets that line in both perpendicular directions by radius. These lines are checked for collisions as well as the balls ending position.
	COLLISION HANDLING:				Physics.js
		BOUNCE:
			Handle case where two surfaces are legit hit at the same time. Average their normals? Alternately handle them in deterministic sequence
			
			
			
			
			
			
LINKAGE!
	Lots of fun physics stuff, but doesnt talk about how to determine what time things happened at.	http://ai.eecs.umich.edu/soar/Classes/494/talks/Lecture%205%20Basic%20Physics.pdf
	Moving circle to static circle collisions, adapt to circle to point collisions???				http://www.heroicvirtuecreations.com/2DCollisions.html
	Awesome but really in depth paper about predictive game engine design:							http://floppsie.comp.glam.ac.uk/Papers/paper21/ieee.pdf
	
BALL WITH BALL COLLISION CODE???? USES LINE BETWEEN BOTH BALLS CENTERS r1 + r2. We only care about r1 and dist from circle to point.
DID NOT ORIGINALLY INCLUDE ACCELERATION, THIS ONE IS UNMODIFIED

We want to know when ||p1-p2|| is less than r, where r is the radius of the ball (AKA THE DESIRED DISTANCE FROM BALL CENTER TO THE COLLISION POINT).

From ball2's perspective, ball1 is moving with velocity v1+v2. At time t, ball2 is at position p2+(v1+v2)*t.

The balls collide when:

(p1-(p2+vt)) = r
-(p2+vt) = r - p1
-p2-vt = r - p1
-vt = r - p1+p2
vt = (p1-p2) - r
Now since ||a|| = ||b||+||c|| when a = b+c, we know that

||v||t = ||p1-p2|| - r
t = (||p1-p2|| - r)/||v||

edit to put the vectormath into pseudocode:

p = p1-p2
v = v1-v2
t = (sqrt(p.x*p.x + p.y*p.y) - r) / sqrt(v.x*v.x + v.y*v.y)


THIS ONE MODIFIED TO INCLUDE ACCELERATION????
We want to know when ||p1-p2|| is less than ||r1||+||r2||, where r1 is the vector with a length of the radius of the first ball in the direction towards the second ball, and r2 is vice-versa.

From ball2's perspective, ball1 is moving with velocity v1+v2. At time t, ball2 is at position p2+(v1+v2)*t.

The balls collide when:

(p1-(p2+vt + (1/2 * a*t^2))) = r
-(p2+vt + (1/2 * a*t^2)) = r - p1
-p2-vt - (1/2 * a*t^2) = r - p1
-vt - (1/2 * a*t^2) = r - p1 + p2
vt + (1/2 * a*t^2) = (p1 - p2) - r
Now since ||d|| = ||b||+||c|| when d = b+c, we know that

||v||t + 1/2 * ||a||t^2 = ||p1-p2|| - r
||v||t + 1/2 * ||a||t^2	- ||p1-p2|| + r = 0										//NEW,	roots are when this = 0. Yields solution????
//t = (||p1-p2|| - r)/||v||														//OLD

//p = p1-p2
//v = v1-v2
//t = (sqrt(p.x*p.x + p.y*p.y) - r) / sqrt(v.x*v.x + v.y*v.y)